# -*- coding: utf-8 -*-
"""
/***************************************************************************
 OnSSET
                                 A QGIS plugin
 This plugin can be used in order to create the input file needed for a basic OnSSET analysis
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2018-07-07
        git sha              : $Format:%H$
        copyright            : (C) 2018 by Babak Khavari
        email                : khavari@kth.se
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
# Import the following packages in order to run code

from PyQt5.QtCore import QSettings, QTranslator, qVersion, QCoreApplication
from PyQt5.QtWidgets import *
import sys
import os
from qgis.core import *
from qgis.gui import *
from PyQt5.QtGui import *
from processing.core.Processing import Processing
Processing.initialize()
import processing

# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .OnSSET_dialog import OnSSETDialog
import os.path


class OnSSET:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'OnSSET_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)

            if qVersion() > '4.3.3':
                QCoreApplication.installTranslator(self.translator)

        # Create the dialog (after translation) and keep reference
        self.dlg = OnSSETDialog()

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&Extract To Excel')
        # TODO: We are going to let the user set this up in a future iteration
        self.toolbar = self.iface.addToolBar(u'OnSSET')
        self.toolbar.setObjectName(u'OnSSET')

        self.dlg.lineEdit.clear()
        self.dlg.toolButton.clicked.connect(self.select_workspace)

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('OnSSET', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            self.toolbar.addAction(action)

        if add_to_menu:
            self.iface.addPluginToDatabaseMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/OnSSET/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'Extract To Excel'),
            callback=self.run,
            parent=self.iface.mainWindow())


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginDatabaseMenu(
                self.tr(u'&Extract To Excel'),
                action)
            self.iface.removeToolBarIcon(action)
        # remove the toolbar
        del self.toolbar

    # Enetering the workspace directory in which the use want to save the outputs of the code. This directory needs to
    # exist
    def select_workspace(self):
        workspace = QFileDialog.getExistingDirectory(self.dlg, "Enter your workspace directory ", "")
        self.dlg.lineEdit.setText(workspace)

    # The name of the study area that is being used. The output file will have this name
    def study_area(self):
        settlement_fc = self.setObjectName(self.dlg, "Enter the name of your study area ", "")
        self.dlg.lineEdit_4.setText(settlement_fc)

    def projCord_func(self):
        projCord = self.mQgsProjectionSelectionWidget(self.dlg, "Enter the CRS")
        self.dlg.mQgsProjectionSelectionWidget.crs(projCord)

    def run(self):
        """Run method that performs all the real work"""
        # Finds all the layers loaded into qgis and makes sure that certain inputs are vectors while others are rasters
        self.dlg.comboBox.clear()
        self.dlg.comboBox_2.clear()
        self.dlg.comboBox_3.clear()
        self.dlg.comboBox_4.clear()
        self.dlg.comboBox_5.clear()
        self.dlg.comboBox_6.clear()
        self.dlg.comboBox_7.clear()
        self.dlg.comboBox_8.clear()
        self.dlg.comboBox_9.clear()
        self.dlg.comboBox_10.clear()
        self.dlg.comboBox_11.clear()
        self.dlg.comboBox_12.clear()
        self.dlg.comboBox_13.clear()
        self.dlg.comboBox_14.clear()
        self.dlg.comboBox_15.clear()

        layers =  QgsProject.instance().mapLayers().values()
        for layer in layers:
            if layer.type()== QgsMapLayer.VectorLayer:
                self.dlg.comboBox.addItem(layer.name(), layer)
                self.dlg.comboBox_10.addItem(layer.name(), layer)
                self.dlg.comboBox_11.addItem(layer.name(), layer)
                self.dlg.comboBox_12.addItem(layer.name(), layer)
                self.dlg.comboBox_13.addItem(layer.name(), layer)


            else:
                self.dlg.comboBox_2.addItem(layer.name(), layer)
                self.dlg.comboBox_3.addItem(layer.name(), layer)
                self.dlg.comboBox_4.addItem(layer.name(), layer)
                self.dlg.comboBox_5.addItem(layer.name(), layer)
                self.dlg.comboBox_6.addItem(layer.name(), layer)
                self.dlg.comboBox_7.addItem(layer.name(), layer)
                self.dlg.comboBox_8.addItem(layer.name(), layer)
                self.dlg.comboBox_9.addItem(layer.name(), layer)

            self.dlg.comboBox_14.addItem(layer.name(), layer)

        layers = [layer for layer in QgsProject.instance().mapLayers().values()]  # Hitta sätt att bara ha vektorer här
        layer_list = []
        for layer in layers:
            if layer.type()== QgsMapLayer.VectorLayer:
                layer_list.append(layer.name())
        #self.dlg.comboBox.addItems(layer_list)


        def layer_field():
            selectedLayerIndex = self.dlg.comboBox_14.currentIndex()
            selectedLayer = layers[selectedLayerIndex]
            fields = selectedLayer.fields()
            fieldnames = [field.name() for field in fields]
            self.dlg.comboBox_15.clear()
            self.dlg.comboBox_15.addItems(fieldnames)

        self.dlg.comboBox_14.currentIndexChanged.connect(layer_field)

        hydropowerFieldUnit = ["W","kW","MW"]
        self.dlg.comboBox_16.addItems(hydropowerFieldUnit)

        # Run the dialog event loop
        result = self.dlg.exec_()
        # See if OK was pressed
        if result:
            # Do something useful here - delete the line containing pass and
            # substitute with your code.

            workspace = self.dlg.lineEdit.text()
            settlements_fc = self.dlg.lineEdit_4.text()
            projCord = self.dlg.mQgsProjectionSelectionWidget.crs().authid()
            hydropowerField = str(self.dlg.comboBox_15.currentText())
            hydropowerFieldUnit = str(self.dlg.comboBox_16.currentText())

            # We will create the folders needed for the analysis here. There is no need for the user to do so.
            # All the user has to do is to create the workspace mentioned above
            if not os.path.exists(workspace + r"/Assist"):
                os.makedirs(workspace + r"/Assist")

            if not os.path.exists(workspace + r"/Assist2"):
                os.makedirs(workspace + r"/Assist2")

            if not os.path.exists(workspace + r"/DEM"):
                os.makedirs(workspace + r"/DEM")

            if not os.path.exists(workspace + r"/Hydropower"):
                os.makedirs(workspace + r"/Hydropower")

            if not os.path.exists(workspace + r"/Land_Cover"):
                os.makedirs(workspace + r"/Land_Cover")

            if not os.path.exists(workspace + r"/Night_Time_Lights"):
                os.makedirs(workspace + r"/Night_Time_Lights")

            if not os.path.exists(workspace + r"/Population_2015"):
                os.makedirs(workspace + r"/Population_2015")

            if not os.path.exists(workspace + r"/Roads"):
                os.makedirs(workspace + r"/Roads")

            if not os.path.exists(workspace + r"/Slope"):
                os.makedirs(workspace + r"/Slope")

            if not os.path.exists(workspace + r"/Solar"):
                os.makedirs(workspace + r"/Solar")

            if not os.path.exists(workspace + r"/Solar_restrictions"):
                os.makedirs(workspace + r"/Solar_restrictions")

            if not os.path.exists(workspace + r"/Substations"):
                os.makedirs(workspace + r"/Substations")

            if not os.path.exists(workspace + r"/Transmission_Network"):
                os.makedirs(workspace + r"/Transmission_Network")

            if not os.path.exists(workspace + r"/Travel_time"):
                os.makedirs(workspace + r"/Travel_time")

            if not os.path.exists(workspace + r"/Wind"):
                os.makedirs(workspace + r"/Wind")

            assistingFolder = workspace + r"/Assist"
            assistingFolder2 = workspace + r"/Assist2"

            # Defining all the datasets used in the analysis
            pop = self.dlg.comboBox_2.currentData()
            ghi = self.dlg.comboBox_3.currentData()
            windvel = self.dlg.comboBox_4.currentData()
            travel = self.dlg.comboBox_5.currentData()
            grid_existing = self.dlg.comboBox_10.currentData()
            grid_planned = self.dlg.comboBox_11.currentData()
            hydro_points = self.dlg.comboBox_14.currentData()
            admin = self.dlg.comboBox.currentData()
            roads = self.dlg.comboBox_13.currentData()
            nightlight = self.dlg.comboBox_6.currentData()
            substations = self.dlg.comboBox_12.currentData()
            elevation = self.dlg.comboBox_7.currentData()
            slope = 'slope'
            land_cover = self.dlg.comboBox_8.currentData()
            solar_restriction = self.dlg.comboBox_9.currentData()

            # Creata a "extent" layer, this will be used to clip all the other datasets in the analysis, this way we
            # will not have null values caused by missing extents.
            ext = admin.extent()

            xmin = ext.xMinimum()-1
            xmax = ext.xMaximum()+1
            ymin = ext.yMinimum()-1
            ymax = ext.yMaximum()+1

            # Createas a coords string. This is important furher down below when we specify that the datasets should
            # be clipped with the extent
            coords = '{},{},{},{}'.format(xmin, xmax, ymin, ymax)

            # Clip population map with admin
            processing.run("gdal:cliprasterbymasklayer",
                           {'INPUT': pop, 'MASK': admin, 'NODATA': None, 'ALPHA_BAND': False,
                            'CROP_TO_CUTLINE': True, 'KEEP_RESOLUTION': True, 'OPTIONS': '', 'DATA_TYPE': 5,
                            'OUTPUT': workspace + r'/Population_2015/pop2015_' + settlements_fc[0:3] + '.tif'})

            # Create a point layer of the clipped population map
            processing.run("saga:rastervaluestopoints",
                           {'GRIDS': [workspace + r'/Population_2015/pop2015_' + settlements_fc[0:3] + '.tif'],
                            'POLYGONS': None, 'NODATA        ': True, 'TYPE': 0,
                            'SHAPES': workspace + r'/Population_2015/Pop.shp'})

            # Add coordiantes in degrees to the points
            processing.run("saga:addcoordinatestopoints", {'INPUT': workspace + r'/Population_2015/Pop.shp',
                                                           'OUTPUT': assistingFolder2 + r'/Pop_With_Coord.shp'})

            # Projecting the population points
            processing.run("native:reprojectlayer",
                           {'INPUT':  assistingFolder2 + r'/Pop_With_Coord.shp', 'TARGET_CRS':  projCord,
                            'OUTPUT': workspace + r'/Population_2015/pop2015.shp'})

            Pop = QgsVectorLayer(workspace + r'/Population_2015/pop2015.shp', '', 'ogr')
            projCord = Pop.crs().authid()

            # Identify the field showing the population by name
            field_ids = []
            fieldnames = set(['pop2015' + settlements_fc[0:3], 'X', 'Y'])
            for field in Pop.fields():
                if field.name() not in fieldnames:
                    field_ids.append(Pop.fields().indexFromName(field.name()))

            # Remove all other fields
            Pop.dataProvider().deleteAttributes(field_ids)
            Pop.updateFields()

            # Change fieldname to something appropriate for the coordinates
            for field in Pop.fields():
                if field.name() == 'X':
                    with edit(Pop):
                        idx = Pop.fields().indexFromName(field.name())
                        Pop.renameAttribute(idx, 'X_deg')
                elif field.name() == 'Y':
                    with edit(Pop):
                        idx = Pop.fields().indexFromName(field.name())
                        Pop.renameAttribute(idx, 'Y_deg')



            # Rasters
            # Create elevation and slope maps.
            # 1. Clip the elevation map with the extent layer.
            # 2. Create a terrain slope map with the elevation layer
            # 3. Reprojects the slope and elevation maps to the coordinates specified above
            # 4. Interpolates the elevation and slope maps in order to avoid null values
            processing.run("gdal:cliprasterbyextent",
                           {'INPUT': elevation, 'PROJWIN': coords, 'NODATA': None,
                            'OPTIONS': '', 'DATA_TYPE': 5,
                            'OUTPUT': workspace + r'/DEM/elevation_' + settlements_fc[0:3] + '.tif'})
            processing.run("gdal:slope",
                           {'INPUT':  workspace + r'/DEM/elevation_' + settlements_fc[0:3] + '.tif', 'BAND': 1,
                            'SCALE': 111120, 'AS_PERCENT': False, 'COMPUTE_EDGES': False, 'ZEVENBERGEN': False,
                            'OPTIONS': '', 'OUTPUT': workspace + r"/Slope/" + slope + '_' + settlements_fc[0:3] + ".tif"})
            processing.run("gdal:warpreproject",
                           {'INPUT': workspace + r"/Slope/" + slope + '_' + settlements_fc[0:3] + ".tif", 'SOURCE_CRS': None,
                            'TARGET_CRS':str(projCord), 'NODATA': 0, 'TARGET_RESOLUTION': 0, 'OPTIONS': '', 'RESAMPLING': 0,
                            'DATA_TYPE': 5, 'TARGET_EXTENT': None, 'TARGET_EXTENT_CRS': None, 'MULTITHREADING': False,
                            'OUTPUT': workspace + r'/Slope/' + slope + settlements_fc[0:3] + '_Proj.tif'})
            processing.run("gdal:warpreproject",
                           {'INPUT': workspace + r'/DEM/elevation_' + settlements_fc[0:3] + '.tif',
                            'SOURCE_CRS': None, 'TARGET_CRS': str(projCord), 'NODATA': 0, 'TARGET_RESOLUTION': 0,
                            'OPTIONS': '', 'RESAMPLING': 0, 'DATA_TYPE': 5, 'TARGET_EXTENT': None,
                            'TARGET_EXTENT_CRS': None, 'MULTITHREADING': False,
                            'OUTPUT': workspace + r'/DEM/elevation' + settlements_fc[0:3] + '_Proj.tif'})
            processing.run("gdal:fillnodata",
                           {'INPUT': workspace + r'/Slope/' + slope + settlements_fc[0:3] + '_Proj.tif', 'BAND': 1,
                            'DISTANCE': 10, 'ITERATIONS': 0, 'NO_MASK': False, 'MASK_LAYER': None,
                            'OUTPUT': assistingFolder2 + r'/' + slope + ".tif"})
            processing.run("gdal:fillnodata",
                           {'INPUT': workspace + r'/DEM/elevation' + settlements_fc[0:3] + '_Proj.tif', 'BAND': 1,
                            'DISTANCE': 10, 'ITERATIONS': 0, 'NO_MASK': False, 'MASK_LAYER': None,
                            'OUTPUT': assistingFolder2 + r'/elevation' + ".tif"})

            # GHI
            # 1. Clip the ghi map with the extent layer.
            # 2. Reprojects the ghi map to the coordinates specified above
            # 3. Interpolates the ghi map in order to avoid null values
            processing.run("gdal:cliprasterbyextent",
                           {'INPUT': ghi, 'PROJWIN': coords, 'NODATA': None,
                            'OPTIONS': '', 'DATA_TYPE': 5,
                            'OUTPUT': workspace + r'/Solar/ghi_' + settlements_fc[0:3] + '.tif'})
            processing.run("gdal:warpreproject",
                           {'INPUT': workspace + r'/Solar/ghi_' + settlements_fc[0:3] + '.tif', 'SOURCE_CRS': None,
                            'TARGET_CRS': projCord, 'NODATA': 0, 'TARGET_RESOLUTION': 0, 'OPTIONS': '', 'RESAMPLING': 0,
                            'DATA_TYPE': 5, 'TARGET_EXTENT': None, 'TARGET_EXTENT_CRS': None, 'MULTITHREADING': False,
                            'OUTPUT': workspace + r'/Solar/ghi_' + settlements_fc[0:3] + '_Proj.tif'})
            processing.run("gdal:fillnodata",
                           {'INPUT':  workspace + r'/Solar/ghi_' + settlements_fc[0:3] + '_Proj.tif', 'BAND': 1,
                            'DISTANCE': 10, 'ITERATIONS': 0, 'NO_MASK': False, 'MASK_LAYER': None,
                            'OUTPUT': assistingFolder2 + r'/ghi.tif'})

            # Traveltime
            # 1. Clip the traveltime map with the extent layer.
            # 2. Reprojects the traveltime map to the coordinates specified above
            # 3. Interpolates the traveltime map in order to avoid null values
            processing.run("gdal:cliprasterbyextent",
                           {'INPUT': travel, 'PROJWIN': coords, 'NODATA': None,
                            'OPTIONS': '', 'DATA_TYPE': 5,
                            'OUTPUT': workspace + r'/Travel_time/travel_' + settlements_fc[0:3] + '.tif'})
            processing.run("gdal:warpreproject",
                           {'INPUT': workspace + r'/Travel_time/travel_' + settlements_fc[0:3] + '.tif',
                            'SOURCE_CRS': None, 'TARGET_CRS': projCord, 'NODATA': 0, 'TARGET_RESOLUTION': 0,
                            'OPTIONS': '', 'RESAMPLING': 0, 'DATA_TYPE': 5, 'TARGET_EXTENT': None,
                            'TARGET_EXTENT_CRS': None, 'MULTITHREADING': False,
                            'OUTPUT': workspace + r'/Travel_time/travel_' + settlements_fc[0:3] + '_Proj.tif'})
            processing.run("gdal:fillnodata",
                           {'INPUT': workspace + r'/Travel_time/travel_' + settlements_fc[0:3] + '_Proj.tif',
                            'BAND': 1, 'DISTANCE': 10, 'ITERATIONS': 0, 'NO_MASK': False, 'MASK_LAYER': None,
                            'OUTPUT': assistingFolder2 + r'/travel.tif'})

            # Wind
            # 1. Clip the wind velocity map with the extent layer.
            # 2. Reprojects the wind velocity map to the coordinates specified above
            # 3. Interpolates the wind velocity map in order to avoid null values
            processing.run("gdal:cliprasterbyextent",
                           {'INPUT': windvel, 'PROJWIN': coords, 'NODATA': None,
                            'OPTIONS': '', 'DATA_TYPE': 5,
                            'OUTPUT': workspace + r'/Wind/windvel_' + settlements_fc[0:3] + '.tif'})
            processing.run("gdal:warpreproject",
                           {'INPUT':workspace + r'/Wind/windvel_' + settlements_fc[0:3] + '.tif', 'SOURCE_CRS': None,
                            'TARGET_CRS': projCord, 'NODATA': 0, 'TARGET_RESOLUTION': 0, 'OPTIONS': '', 'RESAMPLING': 0,
                            'DATA_TYPE': 5, 'TARGET_EXTENT': None, 'TARGET_EXTENT_CRS': None, 'MULTITHREADING': False,
                            'OUTPUT': workspace + r'/Wind/windvel_' + settlements_fc[0:3] + '_Proj.tif'})
            processing.run("gdal:fillnodata",
                           {'INPUT': workspace + r'/Wind/windvel_' + settlements_fc[0:3] + '_Proj.tif', 'BAND': 1,
                            'DISTANCE': 10, 'ITERATIONS': 0, 'NO_MASK': False, 'MASK_LAYER': None,
                            'OUTPUT': assistingFolder2 + r'/windvel.tif'})

            # Solar restriction
            # 1. Clip the solar restriction map with the extent layer.
            # 2. Reprojects the solar restriction map to the coordinates specified above
            # This dataset is not interpolated as it is  discrete
            processing.run("gdal:cliprasterbyextent",
                           {'INPUT': solar_restriction,'PROJWIN': coords, 'NODATA': None, 'OPTIONS': '', 'DATA_TYPE': 5,
                            'OUTPUT': workspace + r'/Solar_restrictions/solar_restriction_' + settlements_fc[0:3] + '.tif'})
            processing.run("gdal:warpreproject", {
                'INPUT': workspace + r'/Solar_restrictions/solar_restriction_' + settlements_fc[0:3] + '.tif',
                'SOURCE_CRS': None, 'TARGET_CRS': projCord, 'NODATA': 0, 'TARGET_RESOLUTION': 0, 'OPTIONS': '',
                'RESAMPLING': 0, 'DATA_TYPE': 5, 'TARGET_EXTENT': None, 'TARGET_EXTENT_CRS': None,
                'MULTITHREADING': False, 'OUTPUT': assistingFolder2 + r'/solar_restriction_Proj.tif'})

            # Landcover
            # 1. Clip the landcover map with the extent layer.
            # 2. Reprojects the landcover map to the coordinates specified above
            # This dataset is not interpolated as it is discrete
            processing.run("gdal:cliprasterbyextent",
                           {'INPUT':  land_cover, 'PROJWIN': coords,'NODATA': None, 'OPTIONS': '', 'DATA_TYPE': 5,
                            'OUTPUT': workspace + r'/Land_Cover/land_cover_' + settlements_fc[0:3] + '.tif'})
            processing.run("gdal:warpreproject",
                           {'INPUT':  workspace + r'/Land_Cover/land_cover_' + settlements_fc[0:3] + '.tif',
                            'SOURCE_CRS': None, 'TARGET_CRS': projCord, 'NODATA': 0, 'TARGET_RESOLUTION': 0,
                            'OPTIONS': '', 'RESAMPLING': 0, 'DATA_TYPE': 5, 'TARGET_EXTENT': None,
                            'TARGET_EXTENT_CRS': None, 'MULTITHREADING': False,
                            'OUTPUT': assistingFolder2 + r'/land_cover_Proj.tif'})

            # Nighttimelights
            # 1. Clip the landcover map with the extent layer.
            # 2. Reprojects the landcover map to the coordinates specified above
            # This dataset is not interpolated as it is discrete
            processing.run("gdal:cliprasterbyextent",
                           {'INPUT': nightlight, 'PROJWIN': coords,'NODATA': None, 'OPTIONS': '', 'DATA_TYPE': 5,
                            'OUTPUT': workspace + r'/Night_Time_Lights/nightlight' + settlements_fc[0:3] + '.tif'})
            processing.run("gdal:warpreproject",
                           {'INPUT': workspace + r'/Night_Time_Lights/nightlight' + settlements_fc[0:3] + '.tif',
                            'SOURCE_CRS': None, 'TARGET_CRS': projCord, 'NODATA': 0, 'TARGET_RESOLUTION': 0,
                            'OPTIONS': '', 'RESAMPLING': 0, 'DATA_TYPE': 5, 'TARGET_EXTENT': None,
                            'TARGET_EXTENT_CRS': None, 'MULTITHREADING': False,
                            'OUTPUT': assistingFolder2 + r'/nightlight_Proj.tif'})

            # Define all the rastermaps that have been generated this far
            elevation = QgsRasterLayer(assistingFolder2 + r'/elevation.tif', 'elevation')
            slope = QgsRasterLayer(assistingFolder2 + r'/slope.tif', 'slope')
            solar = QgsRasterLayer(assistingFolder2 + r'/ghi.tif', 'solar')
            traveltime = QgsRasterLayer(assistingFolder2 + r'/travel.tif', 'traveltime')
            windvel = QgsRasterLayer(assistingFolder2 + r'/windvel.tif', 'windvel')
            solar_restrictions = QgsRasterLayer(assistingFolder2 + r'/solar_restriction_Proj.tif','solar_restrictions')
            landcover = QgsRasterLayer(assistingFolder2 + r'/land_cover_Proj.tif','landcover')
            nightlights = QgsRasterLayer(assistingFolder2 + r'/nightlight_Proj.tif','nightlights')

            # Add the rastervalues to points adds all the raster values to the population point layer based on coordinates
            processing.run("saga:addrastervaluestopoints", {'SHAPES': Pop,
                                                            'GRIDS': [elevation, landcover, nightlights, slope, solar,
                                                                      solar_restrictions, traveltime, windvel],
                                                            'RESAMPLING': 0,
                                                            'RESULT': assistingFolder2 + r"/SettlementsPlaceholder_withoutID.shp"})
            # We create a new column with for the settlement file. This will be ised in order to match the rows in this
            # dataset with the vector datasets later
            processing.run("qgis:fieldcalculator",
                           {'INPUT': assistingFolder2 + r"/SettlementsPlaceholder_withoutID.shp", 'FIELD_NAME': 'AUTO',
                            'FIELD_TYPE': 0, 'FIELD_LENGTH': 10, 'FIELD_PRECISION': 3, 'NEW_FIELD': True,
                            'FORMULA': ' @row_number ', 'OUTPUT': assistingFolder + r"/SettlementsPlaceholder.shp"})

            # Define layer created above
            settlement = QgsVectorLayer(assistingFolder + r"/SettlementsPlaceholder.shp", "", "ogr")

            # Vector datasets
            # substations
            # 1. Create a column with the name AUTO this is needed in order for all vector files to have at least one column in common
            # 2. Clips and removes all vectors outside the admin raster
            # 3. Reprojects the vector layer
            # 4. Calculates the distance to nearest vector element for all the cells in the population layer (we need
            # the name of a column and we use the ENUM_ID
            # 5. Create a column called AUTO for the distance map, this is needed in order to match every row to the
            # corresponding row in the settlement file (when creating the distance map we loose the previous AUTO column
            processing.run("qgis:fieldcalculator",
                           {'INPUT': substations, 'FIELD_NAME': 'AUTO',
                            'FIELD_TYPE': 0, 'FIELD_LENGTH': 10, 'FIELD_PRECISION': 3, 'NEW_FIELD': True,
                            'FORMULA': ' @row_number ',
                            'OUTPUT': workspace + r'/Substations/substations_with_ID.shp'})
            processing.run("native:clip",
                           {'INPUT': workspace + r'/Substations/substations_with_ID.shp', 'OVERLAY': admin,
                            'OUTPUT': workspace + r'/Substations/substations' + settlements_fc[0:3] + '.shp'})
            processing.run("native:reprojectlayer",
                           {'INPUT': workspace + r'/Substations/substations' + settlements_fc[0:3] + '.shp',
                            'TARGET_CRS': projCord,
                            'OUTPUT': workspace + r'/Substations/substations' + settlements_fc[0:3] + '_Proj.shp'})
            processing.run("qgis:distancetonearesthubpoints", {'INPUT': Pop,
                                                               'HUBS':workspace + r'/Substations/substations' + settlements_fc[0:3] + '_Proj.shp',
                                                               'FIELD': 'AUTO', 'UNIT': 0,
                                                               'OUTPUT': assistingFolder2 + r"\Substationsdist_NO_ID.shp"})
            processing.run("qgis:fieldcalculator",
                           {'INPUT': assistingFolder2 + r"\Substationsdist_NO_ID.shp", 'FIELD_NAME': 'AUTO',
                            'FIELD_TYPE': 0, 'FIELD_LENGTH': 10, 'FIELD_PRECISION': 3, 'NEW_FIELD': True,
                            'FORMULA': ' @row_number ', 'OUTPUT': workspace + r"\Substations\Substationsdist.shp"})

            substationsdist = QgsVectorLayer(workspace + r"\Substations\Substationsdist.shp", "", "ogr")

            # Identify the field showing the substationdist and AUTO
            field_ids = []
            fieldnames = set(['HubDist', 'AUTO'])
            for field in substationsdist.fields():
                if field.name() not in fieldnames:
                    field_ids.append(substationsdist.fields().indexFromName(field.name()))

            # Remove all other columns
            substationsdist.dataProvider().deleteAttributes(field_ids)
            substationsdist.updateFields()

            # rename the hubdist field to SubstationDist
            for field in substationsdist.fields():
                if field.name() == 'HubDist':
                    with edit(substationsdist):
                        idx = substationsdist.fields().indexFromName(field.name())
                        substationsdist.renameAttribute(idx, 'SubstationDist')

            # Hydropower
            # 1. Create a column with the name AUTO this is needed in order for all vector files to have at least one column in common
            # 2. Clips and removes all vectors outside the admin raster
            # 3. Reprojects the vector layer
            # 4. Calculates the distance to nearest vector element for all the cells in the population layer (we need
            # the name of a column and we use the ENUM_ID
            # 5. Create a column called AUTO for the distance map, this is needed in order to match every row to the
            # corresponding row in the settlement file (when creating the distance map we loose the previous AUTO column
            # Step 4 and 5 area done twice, once for hydropower and once for hydroFID due to the distance maps having
            # to be done seperatly
            processing.run("qgis:fieldcalculator",
                           {'INPUT': hydro_points, 'FIELD_NAME': 'AUTO',
                            'FIELD_TYPE': 0, 'FIELD_LENGTH': 10, 'FIELD_PRECISION': 3, 'NEW_FIELD': True,
                            'FORMULA': ' @row_number ',
                            'OUTPUT': workspace + r'/Hydropower/hydro_points_with_ID.shp'})
            processing.run("native:clip",
                           {'INPUT': workspace + r'/Hydropower/hydro_points_with_ID.shp', 'OVERLAY': admin,
                            'OUTPUT': workspace + r'/Hydropower/hydro_points' + settlements_fc[0:3] + '.shp'})
            processing.run("native:reprojectlayer",
                           {'INPUT': workspace + r'/Hydropower/hydro_points' + settlements_fc[0:3] + '.shp',
                            'TARGET_CRS': projCord,
                            'OUTPUT': workspace + r'/Hydropower/hydro_points' + settlements_fc[0:3] + '_Proj.shp'})
            processing.run("qgis:distancetonearesthubpoints", {'INPUT': Pop,
                                                               'HUBS': workspace + r'/Hydropower/hydro_points' + settlements_fc[0:3] + '_Proj.shp',
                                                               'FIELD': 'AUTO', 'UNIT': 0,
                                                               'OUTPUT': assistingFolder2 + r"\HydroFID_NO_ID.shp"})
            processing.run("qgis:distancetonearesthubpoints", {'INPUT': Pop,
                                                               'HUBS': workspace + r'/Hydropower/hydro_points' + settlements_fc[0:3] + '_Proj.shp',
                                                               'FIELD': hydropowerField, 'UNIT': 0,
                                                               'OUTPUT': assistingFolder2 + r"\Hydropower_NO_ID.shp"})
            processing.run("qgis:fieldcalculator",
                           {'INPUT': assistingFolder2 + r"\HydroFID_NO_ID.shp", 'FIELD_NAME': 'AUTO', 'FIELD_TYPE': 0,
                            'FIELD_LENGTH': 10, 'FIELD_PRECISION': 3, 'NEW_FIELD': True, 'FORMULA': ' @row_number ',
                            'OUTPUT': workspace + r"\Hydropower\hydrofid.shp"})
            processing.run("qgis:fieldcalculator",
                           {'INPUT': assistingFolder2 + r"\Hydropower_NO_ID.shp", 'FIELD_NAME': 'AUTO', 'FIELD_TYPE': 0,
                            'FIELD_LENGTH': 10, 'FIELD_PRECISION': 3, 'NEW_FIELD': True, 'FORMULA': ' @row_number ',
                            'OUTPUT': workspace + r"\Hydropower\power.shp"})
            power = QgsVectorLayer(workspace + r"\Hydropower\power.shp", "", "ogr")
            hydrofid = QgsVectorLayer(workspace + r"\Hydropower\hydrofid.shp", "", "ogr")

            # Identify the field showing the hydropower and AUTO
            field_ids = []
            fieldnames = set(['HubName', 'AUTO'])
            for field in power.fields():
                if field.name() not in fieldnames:
                    field_ids.append(power.fields().indexFromName(field.name()))

            # Renmove all other fields
            power.dataProvider().deleteAttributes(field_ids)
            power.updateFields()

            # Change fieldname to Hydropower
            for field in power.fields():
                if field.name() == 'HubName':
                    with edit(power):
                        idx = power.fields().indexFromName(field.name())
                        power.renameAttribute(idx, 'Hydropower')

            # Identify the field showing the hydropower, hydropower distance and AUTO
            field_ids = []
            fieldnames = set(['HubName', 'HubDist', 'AUTO'])
            for field in hydrofid.fields():
                if field.name() not in fieldnames:
                    field_ids.append(hydrofid.fields().indexFromName(field.name()))

            # Remove all other fields
            hydrofid.dataProvider().deleteAttributes(field_ids)
            hydrofid.updateFields()

            # Change fieldname to something appropriate for hydrodist and hydrofid
            for field in hydrofid.fields():
                if field.name() == 'HubName':
                    with edit(hydrofid):
                        idx = hydrofid.fields().indexFromName(field.name())
                        hydrofid.renameAttribute(idx, 'HydropowerFID')
                elif field.name() == 'HubDist':
                    with edit(hydrofid):
                        idx = hydrofid.fields().indexFromName(field.name())
                        hydrofid.renameAttribute(idx, 'HydropowerDist')

            # Existing transmission lines
            # 1. Clips and removes all vectors outside the admin raster
            # 2. Creates a point layer from the lines. Each point has a distance of 100 meters to the closes point
            # 3. Create a column with the name AUTO this is needed in order for all vector files to have at least one column in common
            # 4. Reprojects the vector layer
            # 5. Calculates the distance to nearest vector element for all the cells in the population layer (we need the name of a column and we use the AUTO
            # 6. Create a column called AUTO for the distance map, this is needed in order to match every row to the
            # corresponding row in the settlement file (when creating the distance map we loose the previous AUTO column
            processing.run("native:clip",
                           {'INPUT': grid_existing, 'OVERLAY': admin,
                            'OUTPUT': workspace + r'/Transmission_Network/grid_existing' + settlements_fc[0:3] + '.shp'})
            processing.run("saga:convertlinestopoints", {
                'LINES': workspace + r'/Transmission_Network/grid_existing' + settlements_fc[0:3] + '.shp',
                'ADD         ': True, 'DIST': 0.000833333333,
                'POINTS': workspace + r'/Transmission_Network/grid_existing' + settlements_fc[0:3] + 'Point.shp'})
            processing.run("qgis:fieldcalculator", {
                'INPUT': workspace + r'/Transmission_Network/grid_existing' + settlements_fc[0:3] + 'Point.shp',
                'FIELD_NAME': 'AUTO', 'FIELD_TYPE': 0, 'FIELD_LENGTH': 10, 'FIELD_PRECISION': 3, 'NEW_FIELD': True,
                'FORMULA': ' @row_number ',
                'OUTPUT': workspace + r'/Transmission_Network/grid_existing_Point_ID.shp'})
            processing.run("native:reprojectlayer",
                           {'INPUT': workspace + r'/Transmission_Network/grid_existing_Point_ID.shp',
                            'TARGET_CRS': projCord,
                            'OUTPUT': workspace + r'/Transmission_Network/grid_existing_Point_ID_Proj.shp'})
            processing.run("qgis:distancetonearesthubpoints", {'INPUT': Pop,
                                                               'HUBS': workspace + r'/Transmission_Network/grid_existing_Point_ID_Proj.shp',
                                                               'FIELD': 'AUTO', 'UNIT': 0,
                                                               'OUTPUT': assistingFolder2 + r"/griddistcurrent_NO_ID.shp"})
            processing.run("qgis:fieldcalculator",
                           {'INPUT': assistingFolder2 + r"/griddistcurrent_NO_ID.shp", 'FIELD_NAME': 'AUTO',
                            'FIELD_TYPE': 0, 'FIELD_LENGTH': 10, 'FIELD_PRECISION': 3, 'NEW_FIELD': True,
                            'FORMULA': ' @row_number ',
                            'OUTPUT': workspace + r"\Transmission_Network\griddistcurrent.shp"})
            griddistcurrent = QgsVectorLayer(workspace + r"\Transmission_Network\griddistcurrent.shp", "", "ogr")

            # Identify the field showing the griddist and AUTO
            field_ids = []
            fieldnames = set(['HubDist', 'AUTO'])
            for field in griddistcurrent.fields():
                if field.name() not in fieldnames:
                    field_ids.append(griddistcurrent.fields().indexFromName(field.name()))

            # Remove all other columns
            griddistcurrent.dataProvider().deleteAttributes(field_ids)
            griddistcurrent.updateFields()

            # Change fieldname to griddistcurrent
            for field in griddistcurrent.fields():
                if field.name() == 'HubDist':
                    with edit(griddistcurrent):
                        idx = griddistcurrent.fields().indexFromName(field.name())
                        griddistcurrent.renameAttribute(idx, 'GridDistCurrent')

            # Planned Grid
            # 1. Clips and removes all vectors outside the admin raster
            # 2. Creates a point layer from the lines. Each point has a distance of 100 meters to the closes point
            # 3. Create a column with the name AUTO this is needed in order for all vector files to have at least one column in common
            # 4. Reprojects the vector layer
            # 5. Calculates the distance to nearest vector element for all the cells in the population layer (we need the name of a column and we use the AUTO
            # 6. Create a column called AUTO for the distance map, this is needed in order to match every row to the
            # corresponding row in the settlement file (when creating the distance map we loose the previous AUTO column
            processing.run("native:mergevectorlayers", {
                'LAYERS': [grid_planned,grid_existing],'CRS': None, 'OUTPUT': workspace + r'/Transmission_Network/grid_planned_Merged.shp'})
            processing.run("native:clip",
                           {'INPUT': workspace + r'/Transmission_Network/grid_planned_Merged.shp',
                            'OVERLAY': admin,
                            'OUTPUT': workspace + r'/Transmission_Network/grid_planned_' + settlements_fc[0:3] + '.shp'})
            processing.run("saga:convertlinestopoints", {
                'LINES': workspace + r'/Transmission_Network/grid_planned_' + settlements_fc[0:3] + '.shp',
                'ADD         ': True, 'DIST': 0.000833333333,
                'POINTS': workspace + r'/Transmission_Network/grid_planned_' + settlements_fc[0:3] + '_Point.shp'})
            processing.run("qgis:fieldcalculator", {
                'INPUT': workspace + r'/Transmission_Network/grid_planned_' + settlements_fc[0:3] + '_Point.shp',
                'FIELD_NAME': 'AUTO', 'FIELD_TYPE': 0, 'FIELD_LENGTH': 10, 'FIELD_PRECISION': 3, 'NEW_FIELD': True,
                'FORMULA': ' @row_number ',
                'OUTPUT': workspace + r'/Transmission_Network/grid_planned_Point_ID.shp'})
            processing.run("native:reprojectlayer",
                           {'INPUT': workspace + r'/Transmission_Network/grid_planned_Point_ID.shp',
                            'TARGET_CRS': projCord,
                            'OUTPUT': workspace + r'/Transmission_Network/grid_planned_Point_ID_Proj.shp'})
            processing.run("qgis:distancetonearesthubpoints", {'INPUT': Pop,
                                                               'HUBS': workspace + r'/Transmission_Network/grid_planned_Point_ID_Proj.shp',
                                                               'FIELD': 'AUTO', 'UNIT': 0,
                                                               'OUTPUT': assistingFolder2 + r"\griddistplanned_NO_ID.shp"})
            processing.run("qgis:fieldcalculator",
                           {'INPUT': assistingFolder2 + r"\griddistplanned_NO_ID.shp", 'FIELD_NAME': 'AUTO',
                            'FIELD_TYPE': 0, 'FIELD_LENGTH': 10, 'FIELD_PRECISION': 3, 'NEW_FIELD': True,
                            'FORMULA': ' @row_number ',
                            'OUTPUT': workspace + r"\Transmission_Network\griddistplanned.shp"})
            griddistplanned = QgsVectorLayer(workspace + r"\Transmission_Network\griddistplanned.shp", "", "ogr")

            # Identify the field showing the griddist and AUTO
            field_ids = []
            fieldnames = set(['HubDist', 'AUTO'])
            for field in griddistplanned.fields():
                if field.name() not in fieldnames:
                    field_ids.append(griddistplanned.fields().indexFromName(field.name()))

            # Remove all others
            griddistplanned.dataProvider().deleteAttributes(field_ids)
            griddistplanned.updateFields()

            # Change fieldname to griddistplanned
            for field in griddistplanned.fields():
                if field.name() == 'HubDist':
                    with edit(griddistplanned):
                        idx = griddistplanned.fields().indexFromName(field.name())
                        griddistplanned.renameAttribute(idx, 'GridDistPlanned')

            # Roads
            # 1. Clips and removes all vectors outside the admin raster
            # 2. Creates a point layer from the lines. Each point has a distance of 100 meters to the closes point
            # 3. Create a column with the name AUTO this is needed in order for all vector files to have at least one column in common
            # 4. Reprojects the vector layer
            # 5. Calculates the distance to nearest vector element for all the cells in the population layer (we need the name of a column and we use the AUTO
            # 6. Create a column called AUTO for the distance map, this is needed in order to match every row to the
            # corresponding row in the settlement file (when creating the distance map we loose the previous AUTO column
            processing.run("native:clip", {'INPUT': roads, 'OVERLAY': admin,
                                           'OUTPUT': workspace + r'/Roads/roads_' + settlements_fc[0:3] + '.shp'})
            processing.run("saga:convertlinestopoints",
                           {'LINES':workspace + r'/Roads/roads_' + settlements_fc[0:3] + '.shp',
                            'ADD         ': True, 'DIST': 0.000833333333,
                            'POINTS': workspace + r'/Roads/roads_' + settlements_fc[0:3] + '_Point.shp'})
            processing.run("qgis:fieldcalculator",
                           {'INPUT': workspace + r'/Roads/roads_' + settlements_fc[0:3] + '_Point.shp',
                            'FIELD_NAME': 'AUTO', 'FIELD_TYPE': 0, 'FIELD_LENGTH': 10, 'FIELD_PRECISION': 3,
                            'NEW_FIELD': True, 'FORMULA': ' @row_number ',
                            'OUTPUT': workspace + r'/Roads/roads_with_ID.shp'})
            processing.run("native:reprojectlayer",
                           {'INPUT': workspace + r'/Roads/roads_with_ID.shp', 'TARGET_CRS': projCord,
                            'OUTPUT': workspace + r'/Roads/roads_Point_ID_Proj.shp'})
            processing.run("qgis:distancetonearesthubpoints",
                           {'INPUT': Pop, 'HUBS': workspace + r'/Roads/roads_Point_ID_Proj.shp', 'FIELD': 'AUTO',
                            'UNIT': 0, 'OUTPUT': assistingFolder2 + r"\roaddist_NO_ID.shp"})
            processing.run("qgis:fieldcalculator",
                           {'INPUT': assistingFolder2 + r"\roaddist_NO_ID.shp", 'FIELD_NAME': 'AUTO', 'FIELD_TYPE': 0,
                            'FIELD_LENGTH': 10, 'FIELD_PRECISION': 3, 'NEW_FIELD': True, 'FORMULA': ' @row_number ',
                            'OUTPUT': workspace + r"\Roads\roaddist.shp"})
            roaddist = QgsVectorLayer(workspace + r"\Roads\roaddist.shp", "", "ogr")

            # Identify the field showing the roaddist and AUTO
            field_ids = []
            fieldnames = set(['HubDist', 'AUTO'])
            for field in roaddist.fields():
                if field.name() not in fieldnames:
                    field_ids.append(roaddist.fields().indexFromName(field.name()))

            # Removes all other
            roaddist.dataProvider().deleteAttributes(field_ids)
            roaddist.updateFields()

            # Change fieldname to something RoadDist
            for field in roaddist.fields():
                if field.name() == 'HubDist':
                    with edit(roaddist):
                        idx = roaddist.fields().indexFromName(field.name())
                        roaddist.renameAttribute(idx, 'RoadDist')

            # We add every vector to the settlemnt file created above one vector at a time using the coordinates as identifier
            # We do it one at a time in order to more easoly find errors if there are any
            iter1 = processing.run("native:joinattributestable",
                                   {'INPUT': settlement, 'FIELD': 'AUTO', 'INPUT_2': substationsdist, 'FIELD_2': 'AUTO',
                                    'FIELDS_TO_COPY': [], 'METHOD': 1, 'DISCARD_NONMATCHING': False, 'PREFIX': '',
                                    'OUTPUT': assistingFolder + r"\iter1.shp"})
            iter2 = processing.run("native:joinattributestable",
                                   {'INPUT': assistingFolder + r"\iter1.shp", 'FIELD': 'AUTO', 'INPUT_2': roaddist,
                                    'FIELD_2': 'AUTO', 'FIELDS_TO_COPY': [], 'METHOD': 1, 'DISCARD_NONMATCHING': False,
                                    'PREFIX': '', 'OUTPUT': assistingFolder + r"\iter2.shp"})
            iter3 = processing.run("native:joinattributestable",
                                   {'INPUT': assistingFolder + r"\iter2.shp", 'FIELD': 'AUTO',
                                    'INPUT_2': griddistcurrent, 'FIELD_2': 'AUTO', 'FIELDS_TO_COPY': [], 'METHOD': 1,
                                    'DISCARD_NONMATCHING': False, 'PREFIX': '',
                                    'OUTPUT': assistingFolder + r"\iter3.shp"})
            iter4 = processing.run("native:joinattributestable",
                                   {'INPUT': assistingFolder + r"\iter3.shp", 'FIELD': 'AUTO',
                                    'INPUT_2': griddistplanned, 'FIELD_2': 'AUTO', 'FIELDS_TO_COPY': [], 'METHOD': 1,
                                    'DISCARD_NONMATCHING': False, 'PREFIX': '',
                                    'OUTPUT': assistingFolder + r"\iter4.shp"})
            iter5 = processing.run("native:joinattributestable",
                                   {'INPUT': assistingFolder + r"\iter4.shp", 'FIELD': 'AUTO', 'INPUT_2': power,
                                    'FIELD_2': 'AUTO', 'FIELDS_TO_COPY': [], 'METHOD': 1, 'DISCARD_NONMATCHING': False,
                                    'PREFIX': '', 'OUTPUT': assistingFolder + r"\iter5.shp"})
            iter6 = processing.run("native:joinattributestable",
                                   {'INPUT': assistingFolder + r"\iter5.shp", 'FIELD': 'AUTO', 'INPUT_2': hydrofid,
                                    'FIELD_2': 'AUTO', 'FIELDS_TO_COPY': [], 'METHOD': 1, 'DISCARD_NONMATCHING': False,
                                    'PREFIX': '', 'OUTPUT': assistingFolder + r"\iter6.shp"})
            iter7 = processing.run("qgis:fieldcalculator", {'INPUT':assistingFolder + r"\iter6.shp",'FIELD_NAME':
                                    'solarrestr','FIELD_TYPE':0,'FIELD_LENGTH':10,'FIELD_PRECISION':3,'NEW_FIELD':False,
                                    'FORMULA':'CASE WHEN  \"solarrestr\" IS NULL THEN 0 ELSE 1 END',
                                    'OUTPUT':assistingFolder + r"\iter7.shp"})
            iter8 = processing.run("qgis:fieldcalculator", {'INPUT':assistingFolder + r"\iter7.shp",'FIELD_NAME':
                                    'nightlight','FIELD_TYPE':0,'FIELD_LENGTH':10,'FIELD_PRECISION':3,'NEW_FIELD':False,
                                    'FORMULA':'CASE WHEN  \"nightlight\" IS NULL THEN 0 ELSE \"nightlight\" END',
                                    'OUTPUT':assistingFolder + r"\iter8.shp"})
            iter9 = processing.run("qgis:fieldcalculator", {'INPUT':assistingFolder + r"\iter8.shp",'FIELD_NAME':
                                    'landcover','FIELD_TYPE':0,'FIELD_LENGTH':10,'FIELD_PRECISION':3,'NEW_FIELD':False,
                                    'FORMULA':'CASE WHEN  \"landcover\" IS NULL THEN 0 ELSE \"landcover\" END',
                                    'OUTPUT':assistingFolder + r"\iter9.shp"})
            iter10 = processing.run("qgis:fieldcalculator", {'INPUT': assistingFolder + r"\iter9.shp", 'FIELD_NAME':
                                    'traveltime', 'FIELD_TYPE': 0, 'FIELD_LENGTH': 10, 'FIELD_PRECISION': 3, 'NEW_FIELD': False,
                                    'FORMULA': 'CASE WHEN  \"traveltime\" IS NULL THEN 0 ELSE \"traveltime\" END',
                                    'OUTPUT': assistingFolder + r"\iter10.shp"})

            if hydropowerFieldUnit == "W":
                processing.run("qgis:fieldcalculator",
                               {'INPUT': assistingFolder + r"\iter10.shp", 'FIELD_NAME': 'Hydropower',
                                'FIELD_TYPE': 0, 'FIELD_LENGTH': 10, 'FIELD_PRECISION': 3, 'NEW_FIELD': False,
                                'FORMULA': ' \"Hydropower\" /1000', 'OUTPUT': assistingFolder + r"\iter11.shp"})
            elif hydropowerFieldUnit == "MW":
                processing.run("qgis:fieldcalculator",
                               {'INPUT': assistingFolder + r"\iter10.shp", 'FIELD_NAME': 'Hydropower',
                                'FIELD_TYPE': 0, 'FIELD_LENGTH': 10, 'FIELD_PRECISION': 3, 'NEW_FIELD': False,
                                'FORMULA': ' \"Hydropower\" *1000', 'OUTPUT': assistingFolder + r"\iter11.shp"})
            else:
                processing.run("qgis:fieldcalculator",
                               {'INPUT': assistingFolder + r"\iter10.shp", 'FIELD_NAME': 'Hydropower',
                                'FIELD_TYPE': 0, 'FIELD_LENGTH': 10, 'FIELD_PRECISION': 3, 'NEW_FIELD': False,
                                'FORMULA': ' \"Hydropower\" *1', 'OUTPUT': assistingFolder + r"\iter11.shp"})


            # Add coordinates to the settlementfile
            processing.run("saga:addcoordinatestopoints", {'INPUT': assistingFolder + r"\iter11.shp",
                                                           'OUTPUT': assistingFolder + r'/' + settlements_fc + '.shp'})
            settlements = QgsVectorLayer(assistingFolder + r'/' + settlements_fc + '.shp', "", "ogr")

            # Identify all the fileds that we are interested in
            field_ids = []
            fieldnames = set(
                ['X_deg','Y_deg','X', 'Y', 'pop2015' + settlements_fc[0:3], 'elevation', 'landcover', 'nightlight', 'slope', 'solar',
                 'solarrestr', 'traveltime', 'windvel', 'Substation', 'RoadDist', 'GridDistCu', 'GridDistPl',
                 'Hydropower', 'Hydropow_1', 'Hydropow_2'])
            for field in settlements.fields():
                if field.name() not in fieldnames:
                    field_ids.append(settlements.fields().indexFromName(field.name()))

            # Remove all others
            settlements.dataProvider().deleteAttributes(field_ids)
            settlements.updateFields()

            processing.run("qgis:refactorfields",
                           {'INPUT': settlements, 'FIELDS_MAPPING': [
                               {'expression': '"X_deg"', 'length': 18, 'name': 'X_deg', 'precision': 10, 'type': 6},
                               {'expression': '"Y_deg"', 'length': 18, 'name': 'Y_deg', 'precision': 10, 'type': 6},
                               {'expression': '"pop2015Les"', 'length': 18, 'name': 'Pop', 'precision': 10, 'type': 6},
                               {'expression': '"elevation"', 'length': 18, 'name': 'Elevation', 'precision': 10,
                                'type': 6},
                               {'expression': '"landcover"', 'length': 18, 'name': 'LandCover', 'precision': 10,
                                'type': 6},
                               {'expression': '"nightlight"', 'length': 18, 'name': 'NightLights', 'precision': 10,
                                'type': 6},
                               {'expression': '"slope"', 'length': 18, 'name': 'Slope', 'precision': 10, 'type': 6},
                               {'expression': '"solar"', 'length': 18, 'name': 'GHI', 'precision': 10, 'type': 6},
                               {'expression': '"solarrestr"', 'length': 18, 'name': 'SolarRestriction', 'precision': 10,
                                'type': 6},
                               {'expression': '"traveltime"', 'length': 18, 'name': 'TravelHours', 'precision': 10,
                                'type': 6},
                               {'expression': '"windvel"', 'length': 18, 'name': 'WindVel', 'precision': 10, 'type': 6},
                               {'expression': '"Substation"', 'length': 18, 'name': 'SubstationDist', 'precision': 10,
                                'type': 6},
                               {'expression': '"RoadDist"', 'length': 18, 'name': 'RoadDist', 'precision': 10,
                                'type': 6},
                               {'expression': '"GridDistCu"', 'length': 18, 'name': 'GridDistCurrent', 'precision': 10,
                                'type': 6},
                               {'expression': '"GridDistPl"', 'length': 18, 'name': 'GridDistPlan', 'precision': 10,
                                'type': 6},
                               {'expression': '"Hydropower"', 'length': 7, 'name': 'Hydropower', 'precision': 0,
                                'type': 6},
                               {'expression': '"Hydropow_1"', 'length': 5, 'name': 'HydropowerFID', 'precision': 0,
                                'type': 6},
                               {'expression': '"Hydropow_2"', 'length': 18, 'name': 'HydropowerDist', 'precision': 10,
                                'type': 6},
                               {'expression': '"X"', 'length': 18, 'name': 'X', 'precision': 10, 'type': 6},
                               {'expression': '"Y"', 'length': 18, 'name': 'Y', 'precision': 10, 'type': 6}],
                            'OUTPUT': workspace + r"/" + settlements_fc + ".csv"})

            pass